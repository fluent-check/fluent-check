# Fluent API

## Purpose

The core FluentCheck API for building property-based tests using a fluent, chainable interface.
## Requirements
### Requirement: Scenario Builder

The system SHALL provide a `scenario()` function that creates a new FluentCheck instance for building property-based tests.

#### Scenario: Create empty scenario
- **WHEN** `fc.scenario()` is called
- **THEN** a new FluentCheck instance is returned
- **AND** the instance supports method chaining

### Requirement: Universal Quantifier (forall)

The system SHALL provide a `forall(name, arbitrary)` method that binds a named variable to values generated by an arbitrary, asserting the property holds for all generated values.

#### Scenario: Bind single variable
- **WHEN** `.forall('x', fc.integer())` is called
- **THEN** the variable 'x' is bound to generated integer values
- **AND** the type system infers `x` as `number` in subsequent methods

#### Scenario: Bind multiple variables
- **WHEN** `.forall('x', fc.integer()).forall('y', fc.string())` is called
- **THEN** both variables are available in subsequent methods
- **AND** the type system accumulates both bindings (`{x: number, y: string}`)

#### Scenario: Universal assertion fails on counterexample
- **WHEN** a `forall` property is checked
- **AND** a counterexample is found
- **THEN** the result SHALL indicate failure
- **AND** the counterexample SHALL be included in the result

### Requirement: Existential Quantifier (exists)

The system SHALL provide an `exists(name, arbitrary)` method that binds a named variable to values generated by an arbitrary, asserting the property holds for at least one generated value.

#### Scenario: Existential property succeeds on witness
- **WHEN** an `exists` property is checked
- **AND** at least one value satisfies the property
- **THEN** the result SHALL indicate success
- **AND** the satisfying example SHALL be included in the result

#### Scenario: Existential property fails when no witness found
- **WHEN** an `exists` property is checked
- **AND** no generated value satisfies the property
- **THEN** the result SHALL indicate failure

### Requirement: Given Clause

The system SHALL provide a `given(name, valueOrFactory)` method for setting up derived values or constants before assertions, with controlled type inference from factory functions.

#### Scenario: Given with constant value
- **WHEN** `.given('c', 42)` is called
- **THEN** the constant value is available as `c` in subsequent methods

#### Scenario: Given with factory function
- **WHEN** `.given('sum', ({x, y}) => x + y)` is called
- **THEN** the factory is evaluated for each test case
- **AND** the result is available as `sum`

#### Scenario: Chained given clauses
- **WHEN** `.given('a', 1).and('b', ({a}) => a + 1)` is called
- **THEN** `b` can reference the value of `a`

#### Scenario: Type inference from factory return
- **WHEN** both constant and factory positions could infer a type parameter
- **THEN** the factory return type SHALL be the primary inference source
- **AND** type errors SHALL point to the factory function location

### Requirement: When Clause

The system SHALL provide a `when(callback)` method for executing side effects or setup actions that don't produce values.

#### Scenario: Execute setup action
- **WHEN** `.when(({x}) => console.log(x))` is called
- **THEN** the callback is executed for each test case
- **AND** no value is bound to the context

### Requirement: Then Clause (Assertion)

The system SHALL provide a `then(predicate)` method that defines the property to be tested.

#### Scenario: Define property assertion
- **WHEN** `.then(({x, y}) => x + y === y + x)` is called
- **THEN** the predicate is evaluated for each generated test case

#### Scenario: Chained assertions
- **WHEN** `.then(predicate1).and(predicate2)` is called
- **THEN** both predicates must hold for the property to pass

#### Scenario: And clause type inference
- **WHEN** `.and(name, valueOrFactory)` is used after `.then()`
- **THEN** the factory return type SHALL be the primary inference source for type parameter `V`

### Requirement: Check Execution

The system SHALL provide a `check()` method that executes the property-based test and returns a result, while cleanly separating execution from reporting and logging concerns.

#### Scenario: Execute property test
- **WHEN** `.check()` is called
- **THEN** test cases SHALL be generated according to the configured strategy (Explorer, Shrinker, Sampler, and budgets)
- **AND** a `FluentResult` SHALL be returned with:
  - `satisfiable` boolean
  - `example` containing the witness or counterexample (unwrapped from FluentPick)
  - `seed` for reproducibility
  - `statistics` describing execution metrics

#### Scenario: Check orchestration responsibilities
- **WHEN** `check()` orchestrates execution
- **THEN** it SHALL:
  - Build the execution engine from the configured strategy (Explorer, Shrinker, Sampler, budgets, RNG)
  - Execute exploration (and shrinking if necessary)
  - Aggregate raw execution data into `FluentStatistics` using a dedicated `StatisticsAggregator`
  - Construct and return a `FluentResult`
- **AND** it SHALL NOT perform formatting, console output, or framework-specific assertions directly

#### Scenario: Check without observers
- **WHEN** `.check()` is called without any progress or reporting options
- **THEN** the method SHALL execute the property and return a fully-populated `FluentResult`
- **AND** NO progress, logging, or reporting side effects SHALL be produced by default
- **AND** callers SHALL be able to rely solely on assertions over the structured `FluentResult` object

#### Scenario: Observer-based reporting and progress
- **WHEN** progress and reporting are enabled via options
- **THEN** `check()` SHALL delegate to injected observers (e.g., `ProgressReporter`, `ResultReporter`, `Logger`) for:
  - Emitting progress updates
  - Formatting and outputting statistics
  - Logging warnings and debug information
- **AND** the semantics of `FluentResult` and `FluentStatistics` SHALL remain unchanged regardless of observers

### Requirement: Type-Safe Chaining

The system SHALL maintain full type inference through all method chains, accumulating bound variables in a type-safe manner.

#### Scenario: Type inference through chain
- **WHEN** a chain like `.forall('x', fc.integer()).given('y', ({x}) => x * 2).then(({x, y}) => ...)` is constructed
- **THEN** TypeScript SHALL infer correct types for all variables
- **AND** IDE autocompletion SHALL work correctly

### Requirement: Strategy Configuration

The system SHALL provide a `config(strategyFactory)` method to customize test execution behavior.

#### Scenario: Configure sample size
- **WHEN** `.config(fc.strategy().withSampleSize(500))` is called
- **THEN** the test SHALL generate 500 test cases instead of the default

### Requirement: Custom Random Generator

The system SHALL provide a `withGenerator(builder, seed?)` method to use a custom pseudo-random number generator.

#### Scenario: Custom PRNG with seed
- **WHEN** `.withGenerator((seed) => customRng(seed), 12345)` is called
- **THEN** the custom PRNG builder is used for value generation
- **AND** the provided seed is used for reproducibility

#### Scenario: Custom PRNG without seed
- **WHEN** `.withGenerator((seed) => customRng(seed))` is called without a seed
- **THEN** a random seed is generated automatically

### Requirement: Result Type Safety

The FluentCheck result SHALL preserve type information from the fluent chain, enabling type-safe access to example values without manual type assertions.

#### Scenario: Typed example access after check
- **GIVEN** a scenario with `forall('name', arbitrary)` where arbitrary produces type `T`
- **WHEN** the scenario completes via `.check()`
- **THEN** `result.example.name` SHALL be typed as `T`
- **AND** no type assertion SHALL be required to access the value with its correct type

#### Scenario: Multiple bindings preserve types
- **GIVEN** a scenario with multiple `forall` or `exists` bindings
- **WHEN** each binding uses arbitraries of different types
- **THEN** `result.example` SHALL be typed as the intersection of all bound names and their types
- **AND** accessing any bound name SHALL return its correctly typed value

#### Scenario: Backwards compatibility
- **GIVEN** existing code that uses `FluentResult` without explicit type parameters
- **WHEN** the code is compiled with the updated library
- **THEN** compilation SHALL succeed
- **AND** runtime behavior SHALL be unchanged

### Requirement: FluentResult Assertion Methods

The `FluentResult` class SHALL provide assertion methods for fluent test verification.

#### Scenario: Assert satisfiable success
- **WHEN** `assertSatisfiable()` is called on a satisfiable result
- **THEN** no error SHALL be thrown
- **AND** the method SHALL return void

#### Scenario: Assert satisfiable failure
- **WHEN** `assertSatisfiable()` is called on an unsatisfiable result
- **THEN** an error SHALL be thrown
- **AND** the error message SHALL include the counterexample
- **AND** the error message SHALL include the seed for reproducibility

#### Scenario: Assert not satisfiable success
- **WHEN** `assertNotSatisfiable()` is called on an unsatisfiable result
- **THEN** no error SHALL be thrown

#### Scenario: Assert not satisfiable failure
- **WHEN** `assertNotSatisfiable()` is called on a satisfiable result
- **THEN** an error SHALL be thrown
- **AND** the error message SHALL include the found example

#### Scenario: Assert example match
- **WHEN** `assertExample(expected)` is called
- **AND** the result example matches the expected partial object
- **THEN** no error SHALL be thrown

#### Scenario: Assert example mismatch
- **WHEN** `assertExample(expected)` is called
- **AND** the result example does not match the expected partial object
- **THEN** an error SHALL be thrown
- **AND** the error message SHALL indicate which properties differ

#### Scenario: Custom error message
- **WHEN** an assertion method is called with a custom message
- **THEN** the custom message SHALL be included in any thrown error

### Requirement: Property Shorthand

The system SHALL provide a simplified `prop()` function for defining property tests without the full BDD structure.

#### Scenario: Single arbitrary property
- **WHEN** a property is defined with `fc.prop(arb, predicate)`
- **THEN** the property SHALL be tested against values from the arbitrary
- **AND** the predicate SHALL receive the generated value as its argument

#### Scenario: Multiple arbitrary property
- **WHEN** a property is defined with `fc.prop(arb1, arb2, ..., predicate)`
- **THEN** the predicate SHALL receive values from each arbitrary as positional arguments
- **AND** up to 5 arbitraries SHALL be supported

#### Scenario: Property assertion
- **WHEN** `assert()` is called on a property
- **THEN** the property SHALL be checked
- **AND** an error SHALL be thrown if the property is not satisfiable
- **AND** the error message SHALL include the counterexample

#### Scenario: Property check without assertion
- **WHEN** `check()` is called on a property
- **THEN** a `FluentResult` SHALL be returned
- **AND** no error SHALL be thrown regardless of satisfiability

#### Scenario: Property with strategy configuration
- **WHEN** `config(strategy)` is called on a property
- **THEN** the property SHALL use the provided strategy for testing
- **AND** a new `FluentProperty` SHALL be returned for chaining

### Requirement: API Ergonomics Documentation

The system documentation SHALL include comprehensive ergonomics considerations and best practices for fluent API usage.

#### Scenario: Ergonomics research findings documented
- **WHEN** developers reference the fluent API documentation
- **THEN** they SHALL find documented patterns for common testing scenarios
- **AND** recommendations for reducing verbosity SHALL be provided
- **AND** examples demonstrating best practices SHALL be included

#### Scenario: Framework comparison insights
- **WHEN** developers evaluate FluentCheck against other property testing frameworks
- **THEN** documented comparisons SHALL highlight ergonomic advantages
- **AND** design decisions SHALL be explained with rationale
- **AND** trade-offs between verbosity and explicitness SHALL be documented

#### Scenario: Type safety and ergonomics balance
- **WHEN** developers write complex property tests with multiple quantifiers
- **THEN** documentation SHALL provide guidance on maintaining type safety
- **AND** patterns for simplifying complex chains SHALL be demonstrated
- **AND** error message interpretation guidance SHALL be available

### Requirement: Basic Statistics in FluentResult

The system SHALL include basic execution statistics in every FluentResult.

#### Scenario: Statistics available after check
- **WHEN** `.check()` completes
- **THEN** `result.statistics` SHALL be populated with execution metrics
- **AND** existing fields (`satisfiable`, `example`, `seed`, `skipped`) SHALL remain unchanged

#### Scenario: Test count statistics
- **WHEN** tests are executed
- **THEN** `result.statistics.testsRun` SHALL equal the total number of test cases executed
- **AND** `result.statistics.testsPassed` SHALL equal tests where the property held
  - For satisfiable results: `testsPassed = testsRun - skipped`
  - For unsatisfiable results: `testsPassed = testsRun - skipped - 1`
- **AND** `result.statistics.testsDiscarded` SHALL equal tests filtered by preconditions (same as `skipped`)

#### Scenario: Execution time tracking
- **WHEN** tests complete
- **THEN** `result.statistics.executionTimeMs` SHALL contain the total execution time in milliseconds
- **AND** the measured time SHALL be within 10% of actual wall-clock time

### Requirement: Property Helper Functions

The system SHALL provide a `props` namespace with reusable property checking functions.

#### Scenario: Array sorted check
- **WHEN** `fc.props.sorted(arr, comparator?)` is called
- **THEN** it SHALL return `true` if the array is sorted according to the comparator
- **AND** it SHALL use default numeric comparison if no comparator provided

#### Scenario: Array uniqueness check
- **WHEN** `fc.props.unique(arr)` is called
- **THEN** it SHALL return `true` if all elements in the array are unique

#### Scenario: Array non-empty check
- **WHEN** `fc.props.nonEmpty(arr)` is called
- **THEN** it SHALL return `true` if the array has at least one element

#### Scenario: Number range check
- **WHEN** `fc.props.inRange(n, min, max)` is called
- **THEN** it SHALL return `true` if `min <= n <= max`

#### Scenario: String pattern match
- **WHEN** `fc.props.matches(s, pattern)` is called
- **THEN** it SHALL return `true` if the string matches the regex pattern

### Requirement: Composable Mathematical Property Predicates

The system SHALL provide composable predicate functions for mathematical properties that can be used within scenarios.

#### Scenario: Roundtrip predicate
- **WHEN** `fc.props.roundtrips(value, encode, decode)` is called
- **THEN** it SHALL return `true` if `decode(encode(value)) === value`
- **AND** it SHALL be usable within `.then()` clauses

#### Scenario: Idempotent predicate
- **WHEN** `fc.props.isIdempotent(value, fn)` is called
- **THEN** it SHALL return `true` if `fn(fn(value)) === fn(value)`

#### Scenario: Commutative predicate
- **WHEN** `fc.props.commutes(a, b, fn)` is called
- **THEN** it SHALL return `true` if `fn(a, b) === fn(b, a)`

#### Scenario: Associative predicate
- **WHEN** `fc.props.associates(a, b, c, fn)` is called
- **THEN** it SHALL return `true` if `fn(a, fn(b, c)) === fn(fn(a, b), c)`

#### Scenario: Identity predicate
- **WHEN** `fc.props.hasIdentity(value, fn, identity)` is called
- **THEN** it SHALL return `true` if `fn(value, identity) === value` AND `fn(identity, value) === value`

### Requirement: Property Test Templates

The system SHALL provide a `templates` namespace with pre-built property test patterns. Templates SHALL be built on top of `fc.props` predicates for code reuse.

#### Scenario: Roundtrip template
- **WHEN** `fc.templates.roundtrip(arb, encode, decode)` is used
- **THEN** it SHALL test that `decode(encode(x)) === x` for all generated values
- **AND** it SHALL return a checkable property

#### Scenario: Idempotent template
- **WHEN** `fc.templates.idempotent(arb, fn)` is used
- **THEN** it SHALL test that `fn(fn(x)) === fn(x)` for all generated values

#### Scenario: Commutative template
- **WHEN** `fc.templates.commutative(arb, fn)` is used
- **THEN** it SHALL test that `fn(a, b) === fn(b, a)` for all generated value pairs

#### Scenario: Associative template
- **WHEN** `fc.templates.associative(arb, fn)` is used
- **THEN** it SHALL test that `fn(a, fn(b, c)) === fn(fn(a, b), c)` for all generated value triples

#### Scenario: Template returns checkable
- **WHEN** any template is called
- **THEN** it SHALL return an object with `check()` method
- **AND** calling `check()` SHALL execute the property test

### Requirement: Integration with Full Scenarios

Property helpers SHALL be usable within `fc.scenario()` chains, including in `.then()` clauses, `.given()` factories, and with preconditions.

#### Scenario: Using props in then clause
- **WHEN** `fc.props.sorted()` is called within a `.then()` clause
- **THEN** it SHALL evaluate correctly using values from the scenario context
- **AND** it SHALL return a boolean that can be used in the property assertion

#### Scenario: Combining props with given/when/then
- **WHEN** `fc.props` helpers are used in `.given()` factory functions
- **AND** the results are used in `.then()` clauses
- **THEN** the helpers SHALL work correctly with derived values
- **AND** multiple property checks can be chained with `.and()`

#### Scenario: Using props with multiple arbitraries
- **WHEN** `fc.props` helpers are used in scenarios with multiple `.forall()` quantifiers
- **THEN** all context variables SHALL be accessible to the property helpers
- **AND** helpers can reference multiple context variables

#### Scenario: Using props with preconditions
- **WHEN** `fc.props` helpers are used in `fc.pre()` precondition checks
- **THEN** the helpers SHALL work correctly to skip test cases
- **AND** skipped cases SHALL be counted separately from failures

