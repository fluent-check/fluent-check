# Fluent API

## Purpose

The core FluentCheck API for building property-based tests using a fluent, chainable interface.

## Requirements

### Requirement: Scenario Builder

The system SHALL provide a `scenario()` function that creates a new FluentCheck instance for building property-based tests.

#### Scenario: Create empty scenario
- **WHEN** `fc.scenario()` is called
- **THEN** a new FluentCheck instance is returned
- **AND** the instance supports method chaining

### Requirement: Universal Quantifier (forall)

The system SHALL provide a `forall(name, arbitrary)` method that binds a named variable to values generated by an arbitrary, asserting the property holds for all generated values.

#### Scenario: Bind single variable
- **WHEN** `.forall('x', fc.integer())` is called
- **THEN** the variable 'x' is bound to generated integer values
- **AND** the type system infers `x` as `number` in subsequent methods

#### Scenario: Bind multiple variables
- **WHEN** `.forall('x', fc.integer()).forall('y', fc.string())` is called
- **THEN** both variables are available in subsequent methods
- **AND** the type system accumulates both bindings (`{x: number, y: string}`)

#### Scenario: Universal assertion fails on counterexample
- **WHEN** a `forall` property is checked
- **AND** a counterexample is found
- **THEN** the result SHALL indicate failure
- **AND** the counterexample SHALL be included in the result

### Requirement: Existential Quantifier (exists)

The system SHALL provide an `exists(name, arbitrary)` method that binds a named variable to values generated by an arbitrary, asserting the property holds for at least one generated value.

#### Scenario: Existential property succeeds on witness
- **WHEN** an `exists` property is checked
- **AND** at least one value satisfies the property
- **THEN** the result SHALL indicate success
- **AND** the satisfying example SHALL be included in the result

#### Scenario: Existential property fails when no witness found
- **WHEN** an `exists` property is checked
- **AND** no generated value satisfies the property
- **THEN** the result SHALL indicate failure

### Requirement: Given Clause

The system SHALL provide a `given(name, valueOrFactory)` method for setting up derived values or constants before assertions.

#### Scenario: Given with constant value
- **WHEN** `.given('c', 42)` is called
- **THEN** the constant value is available as `c` in subsequent methods

#### Scenario: Given with factory function
- **WHEN** `.given('sum', ({x, y}) => x + y)` is called
- **THEN** the factory is evaluated for each test case
- **AND** the result is available as `sum`

#### Scenario: Chained given clauses
- **WHEN** `.given('a', 1).and('b', ({a}) => a + 1)` is called
- **THEN** `b` can reference the value of `a`

### Requirement: When Clause

The system SHALL provide a `when(callback)` method for executing side effects or setup actions that don't produce values.

#### Scenario: Execute setup action
- **WHEN** `.when(({x}) => console.log(x))` is called
- **THEN** the callback is executed for each test case
- **AND** no value is bound to the context

### Requirement: Then Clause (Assertion)

The system SHALL provide a `then(predicate)` method that defines the property to be tested.

#### Scenario: Define property assertion
- **WHEN** `.then(({x, y}) => x + y === y + x)` is called
- **THEN** the predicate is evaluated for each generated test case

#### Scenario: Chained assertions
- **WHEN** `.then(predicate1).and(predicate2)` is called
- **THEN** both predicates must hold for the property to pass

### Requirement: Check Execution

The system SHALL provide a `check()` method that executes the property-based test and returns a result.

#### Scenario: Execute property test
- **WHEN** `.check()` is called
- **THEN** test cases are generated according to the strategy
- **AND** a FluentResult is returned with `satisfiable` boolean
- **AND** `example` containing the witness or counterexample
- **AND** `seed` for reproducibility

### Requirement: Type-Safe Chaining

The system SHALL maintain full type inference through all method chains, accumulating bound variables in a type-safe manner.

#### Scenario: Type inference through chain
- **WHEN** a chain like `.forall('x', fc.integer()).given('y', ({x}) => x * 2).then(({x, y}) => ...)` is constructed
- **THEN** TypeScript SHALL infer correct types for all variables
- **AND** IDE autocompletion SHALL work correctly

### Requirement: Strategy Configuration

The system SHALL provide a `config(strategyFactory)` method to customize test execution behavior.

#### Scenario: Configure sample size
- **WHEN** `.config(fc.strategy().withSampleSize(500))` is called
- **THEN** the test SHALL generate 500 test cases instead of the default

### Requirement: Custom Random Generator

The system SHALL provide a `withGenerator(builder, seed?)` method to use a custom pseudo-random number generator.

#### Scenario: Custom PRNG with seed
- **WHEN** `.withGenerator((seed) => customRng(seed), 12345)` is called
- **THEN** the custom PRNG builder is used for value generation
- **AND** the provided seed is used for reproducibility

#### Scenario: Custom PRNG without seed
- **WHEN** `.withGenerator((seed) => customRng(seed))` is called without a seed
- **THEN** a random seed is generated automatically
