# Strategies

## Purpose

Test execution strategies that control how property-based tests generate and evaluate test cases.
## Requirements
### Requirement: Strategy Factory

The system SHALL provide a `FluentStrategyFactory` for building customized test strategies using a fluent API.

#### Scenario: Create factory
- **WHEN** `fc.strategy()` is called
- **THEN** a new FluentStrategyFactory instance is returned

#### Scenario: Build strategy
- **WHEN** `.build()` is called on the factory
- **THEN** a configured FluentStrategy instance is returned

#### Scenario: Build strategy lazily at check time
- **GIVEN** a FluentCheck scenario configured with a `FluentStrategyFactory`
- **WHEN** `.check()` (or `.assert()`) is called on the scenario
- **THEN** a `FluentStrategy` instance SHALL be built from the configured factory at execution time
- **AND** that instance SHALL be reused for the entire scenario execution

#### Scenario: Factory method additions
- **WHEN** `FluentStrategyFactory` is extended
- **THEN** it SHALL provide:
  - `withDetailedStatistics(): this` - enables detailed statistics
  - `withVerbosity(level: Verbosity): this` - sets verbosity level
  - Both methods SHALL support fluent chaining

#### Scenario: Factory internal state
- **WHEN** factory methods are called
- **THEN** the factory SHALL store:
  - `detailedStatistics: boolean` (default: false)
  - `verbosity: Verbosity` (default: Normal)
- **AND** this state SHALL be used when building the strategy

#### Scenario: Factory build with statistics
- **WHEN** `factory.build()` is called with detailed statistics enabled
- **THEN** the resulting `FluentStrategy` SHALL include statistics configuration
- **AND** the strategy SHALL create appropriate tracking structures

### Requirement: Default Strategy

The system SHALL provide a `defaultStrategy()` method that configures a sensible default combination of features.

#### Scenario: Default configuration
- **WHEN** `fc.strategy().defaultStrategy().build()` is called
- **THEN** a strategy with random sampling, deduplication, bias, caching, and shrinking is returned

### Requirement: Sample Size Configuration

The system SHALL provide `withSampleSize(n)` to configure the number of test cases generated.

#### Scenario: Configure sample size
- **WHEN** `.withSampleSize(500)` is called
- **THEN** the strategy generates 500 test cases per arbitrary

#### Scenario: Default sample size
- **WHEN** no sample size is configured
- **THEN** 1000 test cases are generated by default

### Requirement: Random Sampling

The system SHALL provide `withRandomSampling()` to enable random test case generation.

#### Scenario: Enable random sampling
- **WHEN** `.withRandomSampling()` is called
- **THEN** test cases are generated randomly using the configured generator

### Requirement: Deduplication

The system SHALL provide `withoutReplacement()` to ensure unique test cases.

#### Scenario: Enable deduplication
- **WHEN** `.withoutReplacement()` is called
- **THEN** duplicate test cases are not tested

### Requirement: Bias Toward Corner Cases

The system SHALL provide `withBias()` to prioritize corner cases during sampling.

#### Scenario: Enable bias
- **WHEN** `.withBias()` is called
- **THEN** corner cases from arbitraries are tested first

### Requirement: Sample Caching

The system SHALL provide `usingCache()` to cache generated samples.

#### Scenario: Enable caching
- **WHEN** `.usingCache()` is called
- **THEN** generated samples are cached and reused

### Requirement: Shrinking Configuration

The system SHALL provide `withShrinking(shrinkSize?)` to enable counterexample minimization.

#### Scenario: Enable shrinking
- **WHEN** `.withShrinking()` is called
- **THEN** failing test cases are shrunk to find minimal counterexamples
- **AND** the default shrink size of 500 candidates is used

#### Scenario: Configure shrink size
- **WHEN** `.withShrinking(1000)` is called
- **THEN** up to 1000 shrink candidates are tested

### Requirement: Strategy Interface

The system SHALL define a `FluentStrategyInterface` with core methods for test execution.

#### Scenario: hasInput method
- **WHEN** `hasInput(arbitraryName)` is called
- **THEN** it returns whether more test inputs are available for that arbitrary

#### Scenario: getInput method
- **WHEN** `getInput(arbitraryName)` is called
- **THEN** it returns the next test input for that arbitrary

#### Scenario: handleResult method
- **WHEN** `handleResult()` is called
- **THEN** it marks the end of one test iteration

#### Scenario: Register arbitraries before execution
- **GIVEN** a FluentCheck scenario with one or more quantifiers (`forall` / `exists`)
- **WHEN** `.check()` (or `.assert()`) is called on the scenario
- **THEN** each quantifier SHALL register its arbitrary with the `FluentStrategy` before any inputs are drawn via `hasInput` / `getInput`

### Requirement: Strategy Composition

The system SHALL support composing strategy features through mixins.

#### Scenario: Combine features
- **WHEN** multiple features like `.withBias().withShrinking().withoutReplacement()` are combined
- **THEN** all features are active in the resulting strategy

### Requirement: Strategy Presets

The system SHALL provide pre-configured strategy presets for common testing scenarios.

#### Scenario: Default strategy preset
- **WHEN** `fc.strategies.default` is used
- **THEN** it SHALL provide a balanced configuration for typical use cases

#### Scenario: Fast strategy preset
- **WHEN** `fc.strategies.fast` is used
- **THEN** it SHALL prioritize quick feedback over thorough coverage
- **AND** it SHALL use random sampling

#### Scenario: Thorough strategy preset
- **WHEN** `fc.strategies.thorough` is used
- **THEN** it SHALL maximize test coverage
- **AND** it SHALL enable random sampling
- **AND** it SHALL enable caching
- **AND** it SHALL enable shrinking
- **AND** it SHALL use sampling without replacement

#### Scenario: Minimal strategy preset
- **WHEN** `fc.strategies.minimal` is used
- **THEN** it SHALL generate a small number of samples (10)
- **AND** it SHALL be suitable for debugging

#### Scenario: Preset compatibility with config
- **WHEN** a strategy preset is passed to `scenario().config()`
- **THEN** the scenario SHALL use the preset's configuration

### Requirement: Explorer Interface

The system SHALL provide an `Explorer<Rec>` interface for navigating the search space of a scenario.

#### Scenario: Explore method signature
- **WHEN** an Explorer is used
- **THEN** it SHALL accept a scenario, property function, sampler, and budget
- **AND** it SHALL return an ExplorationResult

#### Scenario: Explorer is stateless
- **WHEN** an Explorer explores a scenario
- **THEN** the Explorer instance SHALL NOT retain state between explorations

#### Scenario: Explorer with statistics context
- **WHEN** detailed statistics are enabled
- **THEN** the Explorer's `explore()` method SHALL receive a statistics context
- **AND** the Explorer SHALL populate the context during exploration
- **AND** the context SHALL be returned as part of `ExplorationResult`

#### Scenario: AbstractExplorer statistics hooks
- **WHEN** `AbstractExplorer` is extended for statistics
- **THEN** it SHALL provide hooks for:
  - `onSample(quantifierName, value)` - called when a value is sampled
  - `onEvaluate(testCase)` - called before property evaluation
  - `onResult(testCase, passed)` - called after property evaluation

### Requirement: Exploration Budget

The system SHALL provide an `ExplorationBudget` type for controlling exploration limits.

#### Scenario: Max tests budget
- **WHEN** `budget.maxTests` is set to N
- **THEN** the explorer SHALL evaluate the property at most N times

#### Scenario: Optional time budget
- **WHEN** `budget.maxTime` is set
- **THEN** the explorer MAY stop early if time is exceeded

### Requirement: Exploration Result

The system SHALL provide an `ExplorationResult<Rec>` type representing exploration outcomes.

#### Scenario: Passed result
- **WHEN** all tested cases satisfy the property
- **THEN** the result SHALL have `outcome: 'passed'` and `testsRun` count

#### Scenario: Failed result
- **WHEN** a counterexample is found
- **THEN** the result SHALL have `outcome: 'failed'`, `counterexample`, and `testsRun` count

#### Scenario: Exhausted result
- **WHEN** the budget is exhausted before finding failure
- **THEN** the result SHALL have `outcome: 'exhausted'` and `testsRun` count

### Requirement: Nested Loop Explorer

The system SHALL provide a `NestedLoopExplorer` that implements current behavior.

#### Scenario: Forall semantics
- **WHEN** exploring a scenario with only `forall` quantifiers
- **THEN** it SHALL iterate nested loops over all quantifier samples
- **AND** it SHALL fail on the first counterexample found

#### Scenario: Exists semantics
- **WHEN** exploring a scenario with `exists` quantifiers
- **THEN** it SHALL search for a witness that satisfies the property
- **AND** it SHALL succeed when a witness is found

#### Scenario: Given predicate
- **WHEN** a `given` predicate is in the scenario
- **THEN** test cases not satisfying the predicate SHALL be skipped

### Requirement: Explorer Configuration

The system SHALL allow configuring which Explorer implementation to use.

#### Scenario: Configure via factory
- **WHEN** `factory.withNestedExploration()` is called
- **THEN** the resulting checker SHALL use NestedLoopExplorer

#### Scenario: Default explorer
- **WHEN** no explorer is explicitly configured
- **THEN** NestedLoopExplorer SHALL be used by default

### Requirement: Sampler Interface

The system SHALL provide a `Sampler` interface for generating samples from arbitraries.

#### Scenario: Sample method
- **WHEN** `sampler.sample(arbitrary, count)` is called
- **THEN** it SHALL return an array of `FluentPick` values
- **AND** the array length SHALL be at most `count`

#### Scenario: Sample with bias method
- **WHEN** `sampler.sampleWithBias(arbitrary, count)` is called
- **THEN** it SHALL include corner cases from the arbitrary
- **AND** remaining samples SHALL be randomly generated

#### Scenario: Sample unique method
- **WHEN** `sampler.sampleUnique(arbitrary, count)` is called
- **THEN** it SHALL return only unique values
- **AND** uniqueness SHALL be determined by the arbitrary's equals function

#### Scenario: Sampler with statistics
- **WHEN** detailed statistics are enabled and the sampler generates a value
- **THEN** the sampler MAY record distribution data
- **AND** this data SHALL be aggregated with explorer statistics

#### Scenario: Sampler statistics delegation
- **WHEN** sampler decorators are composed (Biased → Cached → Deduping)
- **THEN** statistics collection SHALL occur at the appropriate layer
- **AND** deduplication SHALL be counted before filtering
- **AND** cache hits vs. generations SHALL be distinguishable (in Debug mode)

### Requirement: Random Sampler

The system SHALL provide a `RandomSampler` as the base sampler implementation.

#### Scenario: Random generation
- **WHEN** a RandomSampler samples from an arbitrary
- **THEN** it SHALL use the configured RNG for value generation

#### Scenario: RNG injection
- **WHEN** a RandomSampler is created with a custom RNG
- **THEN** it SHALL use that RNG for all sampling operations

### Requirement: Biased Sampler Decorator

The system SHALL provide a `BiasedSampler` that wraps another sampler.

#### Scenario: Bias toward corner cases
- **WHEN** a BiasedSampler samples from an arbitrary
- **THEN** it SHALL prioritize corner cases before random samples

### Requirement: Cached Sampler Decorator

The system SHALL provide a `CachedSampler` that memoizes samples.

#### Scenario: Cache samples
- **WHEN** a CachedSampler samples from the same arbitrary twice
- **THEN** it SHALL return the cached result on the second call

### Requirement: Deduping Sampler Decorator

The system SHALL provide a `DedupingSampler` that ensures unique samples.

#### Scenario: Deduplicate samples
- **WHEN** a DedupingSampler generates samples
- **THEN** duplicate values SHALL be filtered out

### Requirement: Sampler Composition

The system SHALL support composing samplers via decoration.

#### Scenario: Compose decorators
- **WHEN** `new CachedSampler(new BiasedSampler(new RandomSampler()))` is created
- **THEN** sampling SHALL apply all decorators in order (inner to outer)

### Requirement: Scenario Data Structure

The system SHALL provide a `Scenario<Rec>` type representing an immutable AST of a property test.

#### Scenario: Scenario contains nodes
- **WHEN** a scenario is built from a FluentCheck chain
- **THEN** it SHALL contain an ordered array of nodes representing quantifiers and predicates

#### Scenario: Scenario is immutable
- **WHEN** a scenario is created
- **THEN** its `nodes` array SHALL be readonly
- **AND** individual nodes SHALL be readonly

### Requirement: Scenario Node Types

The system SHALL support different node types in a scenario.

#### Scenario: Forall node
- **WHEN** a `forall` quantifier is in the chain
- **THEN** the scenario SHALL contain a node with `type: 'forall'`, `name`, and `arbitrary`

#### Scenario: Exists node
- **WHEN** an `exists` quantifier is in the chain
- **THEN** the scenario SHALL contain a node with `type: 'exists'`, `name`, and `arbitrary`

#### Scenario: Given node
- **WHEN** a `given` predicate is in the chain
- **THEN** the scenario SHALL contain a node with `type: 'given'` and `predicate`

#### Scenario: Then node
- **WHEN** a `then` predicate is in the chain
- **THEN** the scenario SHALL contain a node with `type: 'then'` and `predicate`

### Requirement: Scenario Derived Properties

The system SHALL provide computed properties on scenarios for analysis.

#### Scenario: Quantifiers list
- **WHEN** `scenario.quantifiers` is accessed
- **THEN** it SHALL return only the quantifier nodes (forall/exists)

#### Scenario: Existential detection
- **WHEN** `scenario.hasExistential` is accessed
- **THEN** it SHALL return true if any `exists` quantifier is present

#### Scenario: Search space size
- **WHEN** `scenario.searchSpaceSize` is accessed
- **THEN** it SHALL return the product of all quantifier arbitrary sizes

### Requirement: Build Scenario from FluentCheck

The system SHALL provide a method to extract a scenario from a FluentCheck chain.

#### Scenario: Build scenario
- **WHEN** `buildScenario()` is called on a FluentCheck instance
- **THEN** it SHALL return a `Scenario<Rec>` representing the full chain
- **AND** node order SHALL match the chain order (root to leaf)

### Requirement: Shrinker Interface

The system SHALL provide a `Shrinker<Rec>` interface for minimizing counterexamples.

#### Scenario: Shrink method signature
- **WHEN** a Shrinker is used
- **THEN** it SHALL accept a counterexample, scenario, property function, sampler, and budget
- **AND** it SHALL return a ShrinkResult

#### Scenario: Shrinker preserves failure
- **WHEN** a Shrinker shrinks a counterexample
- **THEN** the shrunk value SHALL still fail the property

### Requirement: Shrink Budget

The system SHALL provide a `ShrinkBudget` type for controlling shrinking limits.

#### Scenario: Max attempts budget
- **WHEN** `budget.maxAttempts` is set to N
- **THEN** the shrinker SHALL test at most N shrink candidates

#### Scenario: Max rounds budget
- **WHEN** `budget.maxRounds` is set to R
- **THEN** the shrinker SHALL perform at most R shrink iterations

### Requirement: Shrink Result

The system SHALL provide a `ShrinkResult<Rec>` type representing shrinking outcomes.

#### Scenario: Shrunk value
- **WHEN** shrinking completes
- **THEN** the result SHALL contain the minimized counterexample

#### Scenario: Shrink statistics
- **WHEN** shrinking completes
- **THEN** the result SHALL include `attempts` and `rounds` counts

### Requirement: Per-Arbitrary Shrinker

The system SHALL provide a `PerArbitraryShrinker` that shrinks each quantifier independently.

#### Scenario: Shrink individual arbitraries
- **WHEN** shrinking a counterexample with multiple quantifiers
- **THEN** each quantifier's value SHALL be shrunk independently
- **AND** the property SHALL be re-evaluated to confirm failure

#### Scenario: Use arbitrary shrink method
- **WHEN** shrinking a value
- **THEN** it SHALL use the arbitrary's `shrink()` method to generate candidates

### Requirement: No-Op Shrinker

The system SHALL provide a `NoOpShrinker` that disables shrinking.

#### Scenario: Return unchanged
- **WHEN** NoOpShrinker shrinks a counterexample
- **THEN** it SHALL return the counterexample unchanged
- **AND** attempts and rounds SHALL be 0

### Requirement: Shrinker Configuration

The system SHALL allow configuring which Shrinker implementation to use.

#### Scenario: Enable shrinking
- **WHEN** `factory.withShrinking()` is called
- **THEN** the resulting checker SHALL use PerArbitraryShrinker

#### Scenario: Disable shrinking
- **WHEN** `factory.withoutShrinking()` is called
- **THEN** the resulting checker SHALL use NoOpShrinker

#### Scenario: Configure shrink size
- **WHEN** `factory.withShrinking(1000)` is called
- **THEN** the shrinker budget SHALL have maxAttempts of 1000

### Requirement: Confidence-Based Termination

The system SHALL support terminating test execution when sufficient statistical confidence is achieved.

#### Scenario: Terminate at target confidence
- **WHEN** `.withConfidence(0.99)` is configured
- **AND** test execution achieves 99% confidence that property holds
- **THEN** execution terminates early (before sample size limit)
- **AND** the number of tests run is less than the configured sample size

#### Scenario: Higher confidence requires more tests
- **WHEN** the same property is tested with `.withConfidence(0.90)` and `.withConfidence(0.99)`
- **THEN** the 0.99 confidence test runs more tests than the 0.90 confidence test
- **AND** both achieve their respective confidence thresholds

#### Scenario: Continue until minimum confidence
- **WHEN** `.withMinConfidence(0.95)` is configured
- **AND** sample size is reached but confidence is below 95%
- **THEN** execution continues until confidence threshold is met
- **OR** maximum iterations limit is reached

#### Scenario: Safety upper bound
- **WHEN** confidence-based termination is enabled
- **AND** `.withMaxIterations(50000)` is configured
- **THEN** execution never exceeds 50000 iterations regardless of confidence

### Requirement: Pass-Rate Threshold Configuration

The system SHALL allow configuring the pass-rate threshold used for confidence calculation.

#### Scenario: Configure pass-rate threshold
- **WHEN** `.withPassRateThreshold(0.99)` is configured
- **THEN** confidence is calculated as P(pass_rate > 0.99 | data)
- **AND** this produces different confidence values than the default threshold (0.999)

#### Scenario: Default pass-rate threshold
- **WHEN** no pass-rate threshold is configured
- **THEN** the default threshold of 0.999 (99.9%) is used
- **AND** confidence represents P(pass_rate > 0.999 | data)

#### Scenario: Stricter threshold lowers confidence
- **WHEN** the same test results are evaluated with thresholds 0.99 and 0.999
- **THEN** the 0.999 threshold produces lower confidence than 0.99
- **AND** both use the same underlying statistical model

### Requirement: Confidence Terminal Method

The system SHALL provide a convenience method for confidence-based checking.

#### Scenario: Check with confidence
- **WHEN** `.checkWithConfidence(0.999)` is called
- **THEN** property is tested until 99.9% confidence is achieved
- **AND** result includes confidence and credible interval statistics

#### Scenario: Preserve factory configuration
- **WHEN** `.checkWithConfidence(0.95)` is called on a scenario configured with `.config(fc.strategy().withShrinking().withBias())`
- **THEN** the check uses shrinking and bias settings from the configured factory
- **AND** only confidence-related settings are overridden
- **AND** other factory settings (shrinking, bias, deduping, cache, seed) are preserved

### Requirement: Detailed Statistics Configuration

The system SHALL provide a strategy option to enable detailed statistics collection.

#### Scenario: Enable detailed statistics
- **WHEN** `fc.strategy().withDetailedStatistics()` is called
- **THEN** the strategy factory SHALL enable detailed statistics collection
- **AND** per-arbitrary tracking SHALL be activated
- **AND** distribution tracking SHALL be activated for numeric arbitraries

#### Scenario: Detailed statistics disabled by default
- **WHEN** a strategy is created without explicit configuration
- **THEN** detailed statistics SHALL be disabled
- **AND** only basic statistics SHALL be collected
- **AND** there SHALL be zero overhead from detailed statistics tracking

#### Scenario: Detailed statistics chaining
- **WHEN** `withDetailedStatistics()` is called
- **THEN** it SHALL return the factory for method chaining
- **AND** it SHALL be combinable with other strategy options

### Requirement: Verbosity Configuration in Strategy

The system SHALL allow configuring verbosity through the strategy factory.

#### Scenario: Verbosity in factory
- **WHEN** `fc.strategy().withVerbosity(level)` is called
- **THEN** the strategy factory SHALL store the verbosity level
- **AND** the verbosity SHALL be passed to FluentCheck during execution
- **AND** the method SHALL return the factory for chaining

#### Scenario: Verbosity propagation
- **WHEN** a strategy with verbosity is used
- **THEN** the verbosity level SHALL be available to:
  - FluentCheck for controlling output decisions
  - FluentReporter for formatting error messages
  - Explorer for debug output (if Debug level)
  - Progress callbacks (if configured)

#### Scenario: Default verbosity in strategy
- **WHEN** verbosity is not explicitly configured via strategy
- **THEN** `Verbosity.Normal` SHALL be used

### Requirement: Statistics Collection Architecture

The system SHALL collect detailed statistics using the Explorer architecture.

#### Scenario: Statistics collection during exploration
- **WHEN** detailed statistics are enabled
- **THEN** the Explorer SHALL collect per-arbitrary metrics during `explore()`
- **AND** metrics SHALL include:
  - Samples generated per quantifier
  - Unique values per quantifier (tracked via hash set)
  - Corner cases tested per quantifier
  - Distribution data for numeric values (via streaming algorithm)
  - Array/string lengths for collection arbitraries

#### Scenario: Statistics context object
- **WHEN** detailed statistics are enabled
- **THEN** a `StatisticsContext` object SHALL be created at exploration start
- **AND** it SHALL be passed through the exploration pipeline
- **AND** it SHALL aggregate data from all quantifiers

#### Scenario: Statistics per quantifier
- **WHEN** statistics are collected
- **THEN** each quantifier SHALL have its own statistics entry
- **AND** statistics SHALL be keyed by quantifier name
- **AND** statistics SHALL be independent across quantifiers

#### Scenario: Statistics with nested quantifiers
- **WHEN** a scenario has nested quantifiers (e.g., forall within exists)
- **THEN** statistics SHALL be collected for each quantifier independently
- **AND** each quantifier's sample count reflects its actual sampling frequency
- **AND** inner quantifiers may have higher sample counts due to nesting

#### Scenario: Statistics during shrinking
- **WHEN** shrinking is performed after finding a counterexample
- **THEN** shrinking statistics SHALL be tracked separately
- **AND** `result.statistics.shrinking` MAY include:
  - `candidatesTested`: number of shrink candidates evaluated
  - `roundsCompleted`: number of shrinking iterations
  - `improvementsMade`: number of times a smaller counterexample was found

### Requirement: Event and Target Collection Points

The system SHALL provide collection points for events and targets during property evaluation.

#### Scenario: Event collection in property
- **WHEN** `fc.event(name)` is called within a `.then()` property function
- **THEN** the current test case SHALL be tagged with that event
- **AND** the event SHALL be accumulated in the statistics context
- **AND** multiple calls to `fc.event()` with the same name in one test case count as one occurrence

#### Scenario: Target collection in property
- **WHEN** `fc.target(observation, label?)` is called within a `.then()` property function
- **THEN** the observation SHALL be recorded in the statistics context
- **AND** the explorer MAY use this feedback for future generation (implementation-dependent)
- **AND** target statistics SHALL be updated with the observation

#### Scenario: Event/target context availability
- **WHEN** property evaluation begins
- **THEN** `fc.event()` and `fc.target()` SHALL be callable
- **AND** they SHALL have access to the current statistics context
- **AND** calling them outside property evaluation SHALL throw an error with a helpful message

### Requirement: Statistics in ExplorationResult

The system SHALL include detailed statistics in the exploration result.

#### Scenario: ExplorationResult with statistics
- **WHEN** detailed statistics are enabled
- **THEN** `ExplorationResult` SHALL include a `detailedStats` field
- **AND** the field SHALL contain:
  - `arbitraryStats`: per-arbitrary statistics
  - `events`: event counts (if any)
  - `targets`: target statistics (if any)

#### Scenario: ExplorationResult without detailed statistics
- **WHEN** detailed statistics are NOT enabled
- **THEN** `ExplorationResult.detailedStats` SHALL be `undefined`
- **AND** the basic fields (testsRun, skipped, labels) SHALL remain unchanged

### Requirement: Statistics Aggregation in FluentCheck

The system SHALL aggregate statistics from exploration in FluentCheck.

#### Scenario: Aggregation process
- **WHEN** `FluentCheck.check()` completes
- **THEN** it SHALL aggregate statistics from `ExplorationResult`
- **AND** it SHALL calculate final metrics (percentages, distributions)
- **AND** it SHALL include aggregated statistics in `FluentResult.statistics`

#### Scenario: Aggregation with exists quantifiers
- **WHEN** a scenario contains `exists` quantifiers
- **THEN** statistics SHALL reflect all attempts, not just successful witnesses
- **AND** the statistics context SHALL track all evaluated combinations

#### Scenario: Aggregation with given predicates
- **WHEN** a scenario contains `given` predicates
- **THEN** `testsDiscarded` SHALL count filtered test cases
- **AND** `arbitraryStats` distribution, unique values, and corner cases SHALL only include values that passed preconditions
- **AND** `samplesGenerated` SHALL include filtered values to track generation efficiency
- **NOTE** This distinction allows analyzing generator efficiency (discard rate) separate from test coverage

### Requirement: Statistics and Strategy Presets

The system SHALL integrate statistics configuration with strategy presets.

#### Scenario: Default strategy preset
- **WHEN** `fc.strategy().defaultStrategy()` is used
- **THEN** detailed statistics SHALL remain disabled
- **AND** verbosity SHALL remain at Normal

#### Scenario: Debug strategy preset
- **WHEN** a debug-oriented preset is used
- **THEN** detailed statistics SHOULD be enabled
- **AND** verbosity SHOULD be set to Debug
- **NOTE** This preset is for investigating test behavior

#### Scenario: Custom strategy with statistics
- **WHEN** `fc.strategy().withDetailedStatistics().withVerbosity(Verbosity.Verbose).build()` is used
- **THEN** all configured options SHALL be active
- **AND** they SHALL combine correctly with other options (bias, shrinking, etc.)

