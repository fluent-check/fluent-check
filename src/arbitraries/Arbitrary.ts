import type {ArbitrarySize, FluentPick, XOR} from './types.js'
import {ChainedArbitrary, FilteredArbitrary, MappedArbitrary, NoArbitrary} from './internal.js'
import {stringify, stringToHash} from './util.js'

/**
 * Type for hash function returned by hashCode().
 * Uses `unknown` to avoid type variance issues - the actual runtime type is A.
 */
export type HashFunction<A = unknown> = (a: A) => number

/**
 * Type for equality function returned by equals().
 * Uses `unknown` to avoid type variance issues - the actual runtime type is A.
 */
export type EqualsFunction<A = unknown> = (a: A, b: A) => boolean

export abstract class Arbitrary<A> {
  /**
   * The number of elements that can be generated by this `Arbitrary`.
   *
   * The returned size can be exact or an estimation.
   */
  abstract size(): ArbitrarySize

  /**
   * Generates a random element. This operation is stateless.
   */
  abstract pick(generator: () => number): FluentPick<A> | undefined

  /**
   * Returns `true` if this `Arbitrary` can generate a given element.
   *
   * In cases where the set of possible elements is unknown, this operation is expected to be optimistic - it should
   * return `false` only when a pick is guaranteed not to be generatable.
   *
   * TODO: should we include an "unknown" result?
   */
  abstract canGenerate<B extends A>(pick: FluentPick<B>): boolean

  /**
   * Returns a hash function for values generated by this arbitrary.
   * Used for efficient deduplication in sampling methods.
   *
   * Default implementation uses JSON.stringify for objects/arrays and identity for primitives.
   * Subclasses should override for more efficient implementations.
   */
  hashCode(): HashFunction {
    return (a: unknown): number => {
      if (a === null) return 0
      if (a === undefined) return 1
      if (typeof a === 'number') return a | 0
      if (typeof a === 'boolean') return a ? 1 : 0
      if (typeof a === 'string') return stringToHash(a)
      // For objects/arrays, fall back to stringify-based hash
      return stringToHash(stringify(a))
    }
  }

  /**
   * Returns an equality function for values generated by this arbitrary.
   * Used for deterministic comparison in sampling methods.
   *
   * Default implementation uses JSON.stringify for objects/arrays and strict equality for primitives.
   * Subclasses should override for more efficient implementations.
   */
  equals(): EqualsFunction {
    return (a: unknown, b: unknown): boolean => {
      if (a === b) return true
      if (a === null || b === null) return false
      if (a === undefined || b === undefined) return false
      if (typeof a !== typeof b) return false
      if (typeof a === 'object') {
        return stringify(a) === stringify(b)
      }
      return false
    }
  }

  /**
   * Returns a sample of picks of a given size. Sample might contain repeated values
   * and corner cases are not taken into account.
   */
  sample(sampleSize = 10, generator: () => number = Math.random): NonNullable<FluentPick<A>>[] {
    const picks: (FluentPick<A> | undefined)[] = []
    for (let i = 0; i < sampleSize; i++) {
      const pick = this.pick(generator)
      if (pick === undefined) break
      picks.push(pick)
    }
    // TypeScript 5.5 automatically infers NonNullable<FluentPick<A>>[] from filter - no explicit type guard needed!
    return picks.filter((pick) => pick !== undefined)
  }

  /**
   * Returns a sample of picks of a given size without replacement. Sample will
   * not contain repeated values. Corner cases are not taken into account.
   *
   * Uses the arbitrary's hashCode() and equals() functions for efficient deduplication.
   */
  sampleUnique(sampleSize = 10, cornerCases: FluentPick<A>[] = [],
    generator: () => number = Math.random): FluentPick<A>[] {
    const hash = this.hashCode()
    const eq = this.equals()

    // Hash buckets: Map from hash code to array of picks with that hash
    const buckets = new Map<number, FluentPick<A>[]>()
    let resultSize = 0

    const has = (value: A): boolean => {
      const h = hash(value)
      const bucket = buckets.get(h)
      return bucket?.some(p => eq(p.value, value)) ?? false
    }

    const add = (pick: FluentPick<A>): boolean => {
      if (has(pick.value)) return false
      const h = hash(pick.value)
      const bucket = buckets.get(h)
      if (bucket !== undefined) {
        bucket.push(pick)
      } else {
        buckets.set(h, [pick])
      }
      resultSize++
      return true
    }

    // Add corner cases first
    for (const cc of cornerCases) {
      add(cc)
    }

    const initialSize = this.size()
    let bagSize = Math.min(sampleSize, initialSize.value)

    while (resultSize < bagSize) {
      const r = this.pick(generator)
      if (r === undefined) break
      add(r)
      if (initialSize.type !== 'exact') bagSize = Math.min(sampleSize, this.size().value)
    }

    // Flatten buckets to array
    const result: FluentPick<A>[] = []
    for (const bucket of buckets.values()) {
      result.push(...bucket)
    }
    return result
  }

  /**
   * The special cases for this arbitrary, which can be used during sampling to give
   * higher weight to certain elements.
   */
  cornerCases(): FluentPick<A>[] { return [] }

  /**
   * Returns a sample of picks of a given size. Sample might contain repeated values
   * and might be biased toward corner cases (depending on the specific arbitrary
   * implementing or not the cornerCases method).
   */
  sampleWithBias(sampleSize = 10, generator: () => number = Math.random): FluentPick<A>[] {
    const cornerCases = this.cornerCases()

    if (sampleSize <= cornerCases.length)
      return this.sample(sampleSize, generator)

    const sample = this.sample(sampleSize - cornerCases.length, generator)
    sample.unshift(...cornerCases)

    return sample
  }

  /**
   * Returns a sample of picks of a given size. Sample will not contain repeated values
   * and might be biased toward corner cases (depending on the specific arbitrary
   * implementing or not the cornerCases method).
   */
  sampleUniqueWithBias(sampleSize = 10, generator: () => number = Math.random): FluentPick<A>[] {
    const cornerCases = this.cornerCases()

    if (sampleSize <= cornerCases.length)
      return this.sampleUnique(sampleSize, [], generator)

    return this.sampleUnique(sampleSize, cornerCases, generator)
  }

  /**
   * Given a pick known to falsify a property, returns a new arbitrary with simpler cases to be tested. This is part of
   * FluentCheck's behavior of searching for simpler counter-examples after one is found.
   */
  shrink<B extends A>(_initial: FluentPick<B>): Arbitrary<A> {
    return NoArbitrary
  }

  /**
   * Maps a given arbitrary to a new one based on the transformation function (f). Optionally, a shrinkHelper structure
   * that mutually exclusively contains either an inverse map function or an entirely new canGenerate method can be
   * passed. The former allows the mapped arbitrary to be reverted back to its base arbitrary (inverse map === f').
   * Since some transformations cannot be easily inverted, the latter allows entirely overriding the canGenerate method.
   *
   * @remarks
   * Type inference for `B` is controlled: the transformation function `f` is always the primary inference source.
   * The `shrinkHelper` parameter uses `NoInfer<B>` to prevent it from affecting type inference, ensuring that
   * `B` is derived from `f`'s return type rather than from `shrinkHelper`'s parameter types.
   */
  map<B>(f: (a: A) => B,
    shrinkHelper?: XOR<{inverseMap: (b: NoInfer<B>) => A[]},{canGenerate: (pick: FluentPick<NoInfer<B>>) => boolean}>
  ): Arbitrary<B> {
    return new MappedArbitrary(this, f, shrinkHelper)
  }

  /**
   * Filters the generated values to only include those that satisfy the predicate.
   * Values that don't pass the filter will be rejected and regenerated.
   */
  filter(f: (a: A) => boolean): Arbitrary<A> { return new FilteredArbitrary(this, f) }

  /**
   * Alias for `filter`. Filters the generated values to only include those that satisfy the predicate.
   *
   * This method follows the naming convention from QuickCheck and ScalaCheck, where
   * `suchThat` is the standard name for filtered generation. Use whichever name
   * reads more naturally in your context:
   *
   * ```typescript
   * fc.integer().suchThat(x => x > 0)  // "integer such that it's positive"
   * fc.integer().filter(x => x > 0)    // equivalent
   * ```
   */
  suchThat(f: (a: A) => boolean): Arbitrary<A> { return this.filter(f) }

  chain<B>(f: (a: A) => Arbitrary<B>): Arbitrary<B> { return new ChainedArbitrary(this, f) }

  toString(depth = 0): string { return ' '.repeat(depth * 2) + `Base Arbitrary: ${this.constructor.name}`  }

  /**
   * Determines if a candidate pick is a shrunken version of the current pick.
   * Default implementation only rejects identical values (to avoid redundant work),
   * leaving the ordering responsibility to the arbitrary's shrink method.
   * Override to enforce domain-aware ordering as a last line of defence.
   */
  isShrunken(candidate: FluentPick<A>, current: FluentPick<A>): boolean {
    const equals = this.equals()
    return !equals(candidate.value, current.value)
  }
}
