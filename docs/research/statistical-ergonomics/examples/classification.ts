/**
 * Example: Test Case Classification
 * 
 * This example demonstrates how to use classification to understand
 * the distribution of test cases generated by FluentCheck.
 */

import * as fc from 'fluent-check'

// Example 1: Basic classification with predicates
// -------------------------------------------------
// Label test cases based on array length categories

const sortTest = fc.scenario()
  .forall('xs', fc.array(fc.integer(-100, 100)))
  .classify(({xs}) => xs.length === 0, 'empty')
  .classify(({xs}) => xs.length === 1, 'singleton')
  .classify(({xs}) => xs.length >= 2 && xs.length < 10, 'small')
  .classify(({xs}) => xs.length >= 10, 'large')
  .then(({xs}) => {
    const sorted = [...xs].sort((a, b) => a - b)
    // Verify sorted array is a permutation of original
    return sorted.length === xs.length &&
           sorted.every((v, i, arr) => i === 0 || arr[i-1] <= v)
  })
  .check()

console.log('Sort Test Results:')
console.log('  Labels:', sortTest.statistics.labels)
console.log('  Percentages:', sortTest.statistics.labelPercentages)

// Expected output:
// Labels: { empty: 152, singleton: 98, small: 523, large: 227 }
// Percentages: { empty: 15.2, singleton: 9.8, small: 52.3, large: 22.7 }


// Example 2: Dynamic labeling with label()
// ----------------------------------------
// Create labels based on computed values

const mathTest = fc.scenario()
  .forall('x', fc.integer(-1000, 1000))
  .forall('y', fc.integer(-1000, 1000))
  .label(({x, y}) => {
    if (x === 0 || y === 0) return 'has-zero'
    if (x > 0 && y > 0) return 'quadrant-1'
    if (x < 0 && y > 0) return 'quadrant-2'
    if (x < 0 && y < 0) return 'quadrant-3'
    return 'quadrant-4'
  })
  .then(({x, y}) => x + y === y + x)
  .check()

console.log('\nMath Test Results:')
console.log('  Labels:', mathTest.statistics.labels)


// Example 3: Value collection with collect()
// ------------------------------------------
// Automatically collect and count values

const lengthDistribution = fc.scenario()
  .forall('s', fc.string({ minLength: 0, maxLength: 20 }))
  .collect(({s}) => s.length)  // Collects string lengths
  .then(({s}) => typeof s === 'string')
  .check()

console.log('\nString Length Distribution:')
console.log('  Labels:', lengthDistribution.statistics.labels)


// Example 4: Multiple overlapping classifications
// -----------------------------------------------
// A single test case can have multiple labels

const numberProperties = fc.scenario()
  .forall('n', fc.integer(-100, 100))
  .classify(({n}) => n === 0, 'zero')
  .classify(({n}) => n < 0, 'negative')
  .classify(({n}) => n > 0, 'positive')
  .classify(({n}) => n % 2 === 0, 'even')
  .classify(({n}) => n % 2 !== 0, 'odd')
  .classify(({n}) => Math.abs(n) > 50, 'extreme')
  .then(({n}) => n * n >= 0)
  .check()

console.log('\nNumber Properties:')
console.log('  Labels:', numberProperties.statistics.labels)
// Note: Labels don't sum to 100% because they overlap


// Example 5: Chained classification with and()
// --------------------------------------------
// Alternative syntax for multiple classifications

const chainedClassify = fc.scenario()
  .forall('xs', fc.array(fc.nat(100)))
  .classify(({xs}) => xs.length === 0, 'empty')
    .and(({xs}) => xs.some(x => x === 0), 'contains-zero')
    .and(({xs}) => xs.every(x => x < 50), 'all-small')
    .and(({xs}) => new Set(xs).size === xs.length, 'all-unique')
  .then(({xs}) => true)
  .check()

console.log('\nChained Classification:')
console.log('  Labels:', chainedClassify.statistics.labels)


// Example 6: Using classification for debugging
// ---------------------------------------------
// Understand why a property might be failing

const debugTest = fc.scenario()
  .forall('numerator', fc.integer(-100, 100))
  .forall('denominator', fc.integer(-100, 100))
  .classify(({denominator}) => denominator === 0, 'division-by-zero')
  .classify(({numerator, denominator}) => 
    denominator !== 0 && numerator % denominator === 0, 'exact-division')
  .classify(({numerator, denominator}) =>
    denominator !== 0 && numerator % denominator !== 0, 'has-remainder')
  .then(({numerator, denominator}) => {
    if (denominator === 0) return true  // Skip division by zero
    const quotient = Math.floor(numerator / denominator)
    return quotient * denominator <= numerator
  })
  .check()

console.log('\nDivision Test:')
console.log('  Labels:', debugTest.statistics.labels)
// If 'division-by-zero' is high, consider filtering or handling specially
