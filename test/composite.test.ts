import * as fc from '../src/index'
import {it, describe} from 'mocha'
import {expect} from 'chai'
import {
  assertExactSize,
  assertEstimatedSize,
  assertCanGenerate,
  assertCannotGenerate
} from './test-utils.js'

describe('Composite tests', () => {
  describe('basic satisfiability', () => {
    it('finds a string with length 5 in a composite', () => {
      fc.scenario()
        .exists('a', fc.union(fc.string(0, 2), fc.string(4, 6)))
        .then(({a}) => a.length === 5)
        .check()
        .assertSatisfiable()
    })

    it('finds no string with length 3 in a composite', () => {
      fc.scenario()
        .exists('a', fc.union(fc.string(0, 2), fc.string(4, 6)))
        .then(({a}) => a.length === 3)
        .check()
        .assertNotSatisfiable()
    })
  })

  describe('size calculation', () => {
    it('sums sizes of exact arbitraries', () => {
      const union = fc.union(fc.integer(0, 5), fc.integer(10, 15))
      assertExactSize(union.size(), 12) // 6 + 6
    })

    it('returns estimated size when any constituent is estimated', () => {
      const union = fc.union(
        fc.integer(0, 10).filter(n => n > 5),
        fc.integer(-1, 0)
      )
      assertEstimatedSize(union.size())
    })

    it('calculates size with three or more arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 10),
        fc.integer(20, 30),
        fc.integer(40, 50)
      )
      assertExactSize(union.size(), 33) // 11 + 11 + 11
    })

    it('filters out empty arbitraries in size calculation', () => {
      const union = fc.union(
        fc.integer(0, 10),
        fc.empty(),
        fc.integer(20, 30)
      )
      // Should only sum non-empty arbitraries
      assertExactSize(union.size(), 22) // 11 + 11
    })

    it('handles mixed exact and estimated sizes', () => {
      const union = fc.union(
        fc.integer(0, 5), // exact
        fc.integer(0, 10).filter(n => n > 5) // estimated
      )
      assertEstimatedSize(union.size())
    })
  })

  describe('canGenerate behavior', () => {
    it('returns true if any constituent can generate the value', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      assertCanGenerate(union, {value: 5, original: 5})
      assertCanGenerate(union, {value: 25, original: 25})
      assertCannotGenerate(union, {value: 15, original: 15})
    })

    it('returns true when first arbitrary can generate', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      assertCanGenerate(union, {value: 0, original: 0})
      assertCanGenerate(union, {value: 10, original: 10})
    })

    it('returns true when second arbitrary can generate', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      assertCanGenerate(union, {value: 20, original: 20})
      assertCanGenerate(union, {value: 30, original: 30})
    })

    it('returns true when multiple arbitraries can generate (overlapping ranges)', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(5, 15))
      // Value 7 can be generated by both
      assertCanGenerate(union, {value: 7, original: 7})
      assertCanGenerate(union, {value: 5, original: 5})
      assertCanGenerate(union, {value: 10, original: 10})
    })

    it('returns false when no arbitrary can generate', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      assertCannotGenerate(union, {value: 15, original: 15})
      assertCannotGenerate(union, {value: -1, original: -1})
      assertCannotGenerate(union, {value: 31, original: 31})
    })

    it('works with boolean types', () => {
      const union = fc.union(fc.boolean(), fc.boolean()) // Homogeneous union
      assertCanGenerate(union, {value: true, original: true})
      assertCanGenerate(union, {value: false, original: false})
    })

    it('works with three or more arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 10),
        fc.integer(20, 30),
        fc.integer(40, 50)
      )
      assertCanGenerate(union, {value: 5, original: 5})
      assertCanGenerate(union, {value: 25, original: 25})
      assertCanGenerate(union, {value: 45, original: 45})
      assertCannotGenerate(union, {value: 15, original: 15})
    })
  })

  describe('cornerCases behavior', () => {
    it('returns corner cases from all constituents', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      const cases = union.cornerCases()
      const values = cases.map(c => c.value)
      // Should include corner cases from both integer ranges
      expect(values).to.include(0)
      expect(values).to.include(10)
      expect(values).to.include(20)
      expect(values).to.include(30)
    })

    it('handles arbitraries with no corner cases', () => {
      const union = fc.union(
        fc.integer(0, 10),
        fc.integer(0, 10).filter(n => n > 5) // May have fewer corner cases
      )
      const cases = union.cornerCases()
      expect(cases.length).to.be.greaterThan(0)
    })

    it('returns corner cases from multiple arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 5),
        fc.integer(10, 15),
        fc.integer(20, 25)
      )
      const cases = union.cornerCases()
      const values = cases.map(c => c.value)
      expect(values).to.include(0)
      expect(values).to.include(5)
      expect(values).to.include(10)
      expect(values).to.include(15)
      expect(values).to.include(20)
      expect(values).to.include(25)
    })
  })

  describe('shrinking behavior', () => {
    it('shrinks using only matching constituents', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      const initial = {value: 25, original: 25}
      const shrunk = union.shrink(initial)

      // Should only shrink from integer(20, 30), not integer(0, 10)
      expect(shrunk.size().value).to.be.greaterThan(0)
      const samples = shrunk.sample(10)
      expect(samples.length).to.be.greaterThan(0)
      expect(samples.every(s => s.value >= 20 && s.value <= 30)).to.be.true
    })

    it('returns empty arbitrary if no constituent can generate the value', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      const initial = {value: 15, original: 15}
      const shrunk = union.shrink(initial)
      expect(shrunk.size().value).to.equal(0)
    })

    it('shrinks with overlapping ranges (multiple arbitraries can generate)', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(5, 15))
      const initial = {value: 7, original: 7} // Can be generated by both
      const shrunk = union.shrink(initial)

      expect(shrunk.size().value).to.be.greaterThan(0)
      const samples = shrunk.sample(10)
      // Should generate values from either range
      expect(samples.some(s => s.value >= 0 && s.value <= 10)).to.be.true
      expect(samples.some(s => s.value >= 5 && s.value <= 15)).to.be.true
    })

    it('shrinking preserves the ability to generate smaller values', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      const initial = {value: 25, original: 25}
      const shrunk = union.shrink(initial)

      const samples = shrunk.sample(20)
      // All samples should be <= 25 (shrinking should produce smaller values)
      expect(samples.every(s => s.value <= 25)).to.be.true
      expect(samples.some(s => s.value < 25)).to.be.true
    })

    it('shrinks with three or more arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 10),
        fc.integer(20, 30),
        fc.integer(40, 50)
      )
      const initial = {value: 45, original: 45}
      const shrunk = union.shrink(initial)

      expect(shrunk.size().value).to.be.greaterThan(0)
      const samples = shrunk.sample(10)
      expect(samples.every(s => s.value >= 40 && s.value <= 50)).to.be.true
    })
  })

  describe('weighted selection in pick()', () => {
    it('selects arbitraries weighted by size', () => {
      const small = fc.integer(0, 1) // size: 2
      const large = fc.integer(0, 100) // size: 101
      const union = fc.union(small, large)

      // With many samples, large should be selected more often
      const samples = union.sample(1000)
      const fromLarge = samples.filter(s => s.value > 1).length
      // Large has ~98% of the weight (101/103), so expect most samples from large
      expect(fromLarge).to.be.greaterThan(800) // Allow some variance
    })

    it('selection works with three or more arbitraries', () => {
      const tiny = fc.integer(0, 1) // size: 2
      const medium = fc.integer(0, 10) // size: 11
      const large = fc.integer(0, 100) // size: 101
      const union = fc.union(tiny, medium, large)

      const samples = union.sample(1000)
      const fromTiny = samples.filter(s => s.value <= 1).length
      const fromMedium = samples.filter(s => s.value > 1 && s.value <= 10).length
      const fromLarge = samples.filter(s => s.value > 10).length

      // Large should have most samples, then medium, then tiny
      expect(fromLarge).to.be.greaterThan(fromMedium)
      expect(fromMedium).to.be.greaterThan(fromTiny)
    })
  })

  describe('edge cases: empty and single arbitraries', () => {
    it('single arbitrary returns that arbitrary (not a composite)', () => {
      const single = fc.integer(0, 10)
      const union = fc.union(single)
      // union() should return the single arbitrary directly
      expect(union).to.equal(single)
    })

    it('empty arbitraries are filtered out', () => {
      const union = fc.union(fc.integer(0, 10), fc.empty(), fc.integer(20, 30))
      // Should work as if empty wasn't there
      assertCanGenerate(union, {value: 5, original: 5})
      assertCanGenerate(union, {value: 25, original: 25})
      assertExactSize(union.size(), 22) // 11 + 11
    })

    it('all empty arbitraries returns NoArbitrary', () => {
      const union = fc.union(fc.empty(), fc.empty())
      expect(union.size().value).to.equal(0)
    })

    it('union with NoArbitrary is equivalent to union without it', () => {
      const withEmpty = fc.union(fc.integer(0, 10), fc.empty(), fc.integer(20, 30))
      const withoutEmpty = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      expect(withEmpty.size().value).to.equal(withoutEmpty.size().value)
    })
  })

  describe('different types and complex arbitraries', () => {
    it('works with different integer ranges', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      fc.scenario()
        .exists('value', union)
        .then(({value}) => (value >= 0 && value <= 10) || (value >= 20 && value <= 30))
        .check()
        .assertSatisfiable()
    })

    it('works with object types', () => {
      // Test with compatible record types
      const union = fc.union(
        fc.record({x: fc.integer(0, 10), y: fc.integer(0, 1)}),
        fc.record({x: fc.integer(0, 10), y: fc.integer(2, 3)})
      )
      fc.scenario()
        .exists('obj', union)
        .then(({obj}) => 'x' in obj && 'y' in obj)
        .check()
        .assertSatisfiable()
    })

    it('works with array types', () => {
      const union = fc.union(
        fc.array(fc.integer(0, 5), 1, 3),
        fc.array(fc.integer(0, 5), 2, 4) // Use same element type to avoid type issues
      )
      fc.scenario()
        .exists('arr', union)
        .then(({arr}) => arr.length >= 1 && arr.length <= 4)
        .check()
        .assertSatisfiable()
    })

    it('works with tuple types', () => {
      // Use compatible tuple types
      const union = fc.union(
        fc.tuple(fc.integer(0, 10), fc.integer(0, 1)),
        fc.tuple(fc.integer(0, 10), fc.integer(0, 1))
      )
      fc.scenario()
        .exists('tup', union)
        .then(({tup}) => Array.isArray(tup) && tup.length === 2)
        .check()
        .assertSatisfiable()
    })
  })

  describe('overlapping ranges', () => {
    it('handles overlapping ranges', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(5, 15))
      // Value 7 can be generated by both
      assertCanGenerate(union, {value: 7, original: 7})

      fc.scenario()
        .exists('x', union)
        .then(({x}) => x >= 0 && x <= 15)
        .check()
        .assertSatisfiable()
    })

    it('canGenerate returns true for overlapping values', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(5, 15))
      assertCanGenerate(union, {value: 5, original: 5}) // In both
      assertCanGenerate(union, {value: 10, original: 10}) // In both
      assertCanGenerate(union, {value: 7, original: 7}) // In both
    })

    it('shrinking with overlapping ranges works correctly', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(5, 15))
      const initial = {value: 7, original: 7}
      const shrunk = union.shrink(initial)

      expect(shrunk.size().value).to.be.greaterThan(0)
      const samples = shrunk.sample(10)
      // Should be able to generate from either range
      expect(samples.length).to.be.greaterThan(0)
    })

    it('size calculation with overlapping ranges still sums (not deduplicated)', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(5, 15))
      // Should sum sizes: 11 + 11 = 22, not deduplicate
      assertExactSize(union.size(), 22)
    })
  })

  describe('three or more arbitraries', () => {
    it('works with three or more arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 10),
        fc.integer(20, 30),
        fc.integer(40, 50)
      )
      assertExactSize(union.size(), 33) // 11 + 11 + 11
      assertCanGenerate(union, {value: 5, original: 5})
      assertCanGenerate(union, {value: 25, original: 25})
      assertCanGenerate(union, {value: 45, original: 45})
      assertCannotGenerate(union, {value: 15, original: 15})
    })

    it('canGenerate with three or more arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 5),
        fc.integer(10, 15),
        fc.integer(20, 25),
        fc.integer(30, 35)
      )
      assertCanGenerate(union, {value: 2, original: 2})
      assertCanGenerate(union, {value: 12, original: 12})
      assertCanGenerate(union, {value: 22, original: 22})
      assertCanGenerate(union, {value: 32, original: 32})
      assertCannotGenerate(union, {value: 7, original: 7})
    })
  })

  describe('nested unions', () => {
    it('handles nested unions', () => {
      const inner1 = fc.union(fc.integer(0, 5), fc.integer(10, 15))
      const inner2 = fc.union(fc.integer(20, 25), fc.integer(30, 35))
      const outer = fc.union(inner1, inner2)

      assertExactSize(outer.size(), 24) // 12 + 12
      assertCanGenerate(outer, {value: 12, original: 12})
      assertCanGenerate(outer, {value: 22, original: 22})
      assertCannotGenerate(outer, {value: 7, original: 7})
      assertCannotGenerate(outer, {value: 27, original: 27})
    })

    it('canGenerate with nested unions', () => {
      const inner1 = fc.union(fc.integer(0, 5), fc.integer(10, 15))
      const inner2 = fc.union(fc.integer(20, 25), fc.integer(30, 35))
      const outer = fc.union(inner1, inner2)

      assertCanGenerate(outer, {value: 3, original: 3})
      assertCanGenerate(outer, {value: 12, original: 12})
      assertCanGenerate(outer, {value: 22, original: 22})
      assertCanGenerate(outer, {value: 33, original: 33})
    })

    it('shrinking with nested unions', () => {
      const inner1 = fc.union(fc.integer(0, 5), fc.integer(10, 15))
      const inner2 = fc.union(fc.integer(20, 25), fc.integer(30, 35))
      const outer = fc.union(inner1, inner2)

      const initial = {value: 33, original: 33}
      const shrunk = outer.shrink(initial)
      expect(shrunk.size().value).to.be.greaterThan(0)
      const samples = shrunk.sample(10)
      expect(samples.every(s => s.value >= 30 && s.value <= 33)).to.be.true
    })
  })

  describe('integration with transformations', () => {
    it('works with union of mapped arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 10).map(n => n * 2),
        fc.integer(0, 10).map(n => n * 3)
      )
      fc.scenario()
        .exists('x', union)
        .then(({x}) => x % 2 === 0 || x % 3 === 0)
        .check()
        .assertSatisfiable()
    })

    it('works with union of filtered arbitraries', () => {
      const union = fc.union(
        fc.integer(0, 20).filter(n => n % 2 === 0),
        fc.integer(0, 20).filter(n => n % 3 === 0)
      )
      fc.scenario()
        .exists('x', union)
        .then(({x}) => x % 2 === 0 || x % 3 === 0)
        .check()
        .assertSatisfiable()
    })

    it('works with mapping a union', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      const mapped = union.map(n => n * 2)

      fc.scenario()
        .exists('x', mapped)
        .then(({x}) => (x >= 0 && x <= 20) || (x >= 40 && x <= 60))
        .check()
        .assertSatisfiable()
    })

    it('works with filtering a union', () => {
      const union = fc.union(fc.integer(0, 10), fc.integer(20, 30))
      const filtered = union.filter(n => n > 5 && n < 25)

      fc.scenario()
        .exists('x', filtered)
        .then(({x}) => x > 5 && x < 25)
        .check()
        .assertSatisfiable()
    })

    it('works with chaining from a union', () => {
      const union = fc.union(fc.integer(0, 5), fc.integer(10, 15))
      const chained = union.chain(n => fc.array(fc.constant(n), n, n))

      fc.scenario()
        .exists('arr', chained)
        .then(({arr}) => arr.length >= 0 && arr.length <= 15)
        .check()
        .assertSatisfiable()
    })
  })
})
